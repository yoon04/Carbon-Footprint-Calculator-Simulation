<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carbon Footprint Calculator Game - 3D City Builder</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: sans-serif; }
        #instructions {
            position: absolute;
            top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.6); padding: 12px;
            border-radius: 8px; pointer-events: none;
        }
        #toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 10px;
            display: flex;
            gap: 10px;
        }
        #toolbar button {
            padding: 8px 12px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
        }
        #toolbar button.active {
            background: #2196F3;
        }
        #carbon-score {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 12px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <strong>Carbon Footprint City Builder Game</strong><br>
        Build a sustainable city! Place components to see your carbon footprint.<br>
        Trees reduce footprint, factories/cars increase it.<br>
        Goal: Low carbon while building a big city.<br>
        Controls: Rotate (Left Drag), Zoom (Wheel), Place (Click on ground after selecting tool)
    </div>
    <div id="toolbar">
        <button data-type="tree1">Tree 1 (-10 CO2)</button>
        <button data-type="tree2">Tree 2 (-15 CO2)</button>
        <button data-type="house">House (+5 CO2)</button>
        <button data-type="apartment">Apartment (+20 CO2)</button>
        <button data-type="car">Car (+15 CO2)</button>
        <button data-type="bus">Bus (+10 CO2)</button>
        <button data-type="factory">Factory (+50 CO2)</button>
    </div>
    <div id="carbon-score">Carbon Footprint: 0 tons/year</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 40, 50);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(30, 60, 30);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // --- TERRAIN GENERATION (from ground.html) ---
        const gridSize = 60;
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);

        // Materials
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333, flatShading: true }); // Asphalt
        const lineMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, flatShading: true }); // Road Line
        const grassColors = [0x567d46, 0x4d7040, 0x618a4d];
        const dirtMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, flatShading: true });

        const terrainMeshes = []; // To raycast against

        for (let x = -gridSize / 2; x < gridSize / 2; x++) {
            for (let z = -gridSize / 2; z < gridSize / 2; z++) {
                
                let h = 0;
                let currentMat;
                const isRoadX = (x >= -2 && x <= 2); // Road width 5 blocks
                const isRoadZ = (z >= -2 && z <= 2);
                
                // --- ROAD LOGIC ---
                if (isRoadX || isRoadZ) {
                    h = 0; // Roads are always flat at level 0
                    currentMat = roadMat;
                    
                    // Add yellow/white center lines
                    if ((isRoadX && Math.abs(x) < 0.2 && z % 4 === 0) || 
                        (isRoadZ && Math.abs(z) < 0.2 && x % 4 === 0)) {
                        currentMat = lineMat;
                    }
                } 
                // --- PLAIN & HILL LOGIC ---
                else {
                    // Smooth surface in "quadrants"
                    const distToCenter = Math.sqrt(x*x + z*z);
                    
                    if (distToCenter < 15) {
                        h = 0; // Smooth plains near the crossroad
                    } else {
                        // Rolling hills further out
                        h = Math.round(Math.sin(x * 0.15) * 2 + Math.cos(z * 0.15) * 2);
                        if (h < 0) h = 0; 
                    }

                    currentMat = new THREE.MeshStandardMaterial({ 
                        color: grassColors[Math.floor(Math.random() * grassColors.length)],
                        flatShading: true 
                    });
                }

                const block = new THREE.Mesh(boxGeo, currentMat);
                block.position.set(x, h - 0.5, z); // Adjust y to center
                block.receiveShadow = true;
                scene.add(block);
                terrainMeshes.push(block);

                // Underground filler
                for (let y = h - 1; y >= -2; y--) {
                    const filler = new THREE.Mesh(boxGeo, dirtMat);
                    filler.position.set(x, y - 0.5, z);
                    scene.add(filler);
                }
            }
        }

        // --- CONTROLS ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- CARBON FOOTPRINT LOGIC ---
        let carbonFootprint = 0;
        const carbonValues = {
            tree1: -10,
            tree2: -15,
            house: 5,
            apartment: 20,
            car: 15,
            bus: 10,
            factory: 50
        };
        const scoreDisplay = document.getElementById('carbon-score');

        function updateCarbon(value) {
            carbonFootprint += value;
            scoreDisplay.textContent = `Carbon Footprint: ${carbonFootprint} tons/year`;
        }

        // --- MODEL CREATION FUNCTIONS ---
        function createTree1() {
            const tree = new THREE.Group();

            // Trunk
            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 2, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4d2926 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1;
            tree.add(trunk);

            // Leaves
            const leafMat = new THREE.MeshStandardMaterial({ 
                color: 0x2d5a27, 
                flatShading: true 
            });

            const bottomLeaves = new THREE.Mesh(new THREE.ConeGeometry(2, 2.5, 8), leafMat);
            bottomLeaves.position.y = 2.5;
            tree.add(bottomLeaves);

            const midLeaves = new THREE.Mesh(new THREE.ConeGeometry(1.6, 2, 8), leafMat);
            midLeaves.position.y = 3.8;
            tree.add(midLeaves);

            const topLeaves = new THREE.Mesh(new THREE.ConeGeometry(1.1, 1.5, 8), leafMat);
            topLeaves.position.y = 4.8;
            tree.add(topLeaves);

            return tree;
        }

        function createTree2() {
            const tree = new THREE.Group();

            // Materials
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, flatShading: true });
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x388e3c, flatShading: true });

            // Main Trunk
            const mainTrunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 6, 8);
            const mainTrunk = new THREE.Mesh(mainTrunkGeo, trunkMat);
            mainTrunk.position.y = 3;
            tree.add(mainTrunk);

            // Crown
            const crown = new THREE.Mesh(new THREE.IcosahedronGeometry(2, 0), leafMat);
            crown.position.set(0, 6.5, 0);
            tree.add(crown);

            // Function to add branch
            function addBranch(height, angleY, tiltZ, length, leafSize) {
                const branchGroup = new THREE.Group();
                
                const bGeo = new THREE.CylinderGeometry(0.15, 0.3, length, 6);
                const bMesh = new THREE.Mesh(bGeo, trunkMat);
                bMesh.position.y = length / 2;
                branchGroup.add(bMesh);

                const leaf = new THREE.Mesh(new THREE.IcosahedronGeometry(leafSize, 0), leafMat);
                leaf.position.y = length;
                branchGroup.add(leaf);

                branchGroup.position.y = height;
                branchGroup.rotation.z = tiltZ;
                
                const pivot = new THREE.Group();
                pivot.rotation.y = angleY;
                pivot.add(branchGroup);
                
                tree.add(pivot);
            }

            const branchData = [
                { h: 2.5, ay: 0, tz: 1.1, len: 3, s: 1.2 },
                { h: 3.0, ay: Math.PI * 0.5, tz: 0.9, len: 2.5, s: 1.0 },
                { h: 3.5, ay: Math.PI, tz: 1.2, len: 3.2, s: 1.3 },
                { h: 4.0, ay: Math.PI * 1.5, tz: 0.8, len: 2, s: 0.9 },
                { h: 4.5, ay: 0.7, tz: 0.7, len: 2.8, s: 1.1 },
                { h: 5.0, ay: 2.5, tz: 0.6, len: 2.2, s: 0.8 },
                { h: 5.2, ay: 4.2, tz: 1.0, len: 2.5, s: 1.0 },
                { h: 2.0, ay: 5.5, tz: 1.3, len: 3.5, s: 1.4 },
            ];

            branchData.forEach(data => addBranch(data.h, data.ay, data.tz, data.len, data.s));

            return tree;
        }

        function createHouse() {
            const house = new THREE.Group();

            // Materials
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xddc9a3, flatShading: true });
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, flatShading: true });
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
            const windowMat = new THREE.MeshStandardMaterial({ color: 0xadd8e6, emissive: 0xadd8e6, emissiveIntensity: 0.2 });

            // Main Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 5), wallMat);
            body.position.y = 2;
            house.add(body);

            // Roof
            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(4.5, 3, 4), 
                roofMat
            );
            roof.position.y = 5.5;
            roof.rotation.y = Math.PI / 4;
            house.add(roof);

            // Chimney
            const chimney = new THREE.Mesh(new THREE.BoxGeometry(0.8, 2, 0.8), roofMat);
            chimney.position.set(1.5, 5.5, 0.5);
            house.add(chimney);

            // Door
            const door = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2, 0.1), doorMat);
            door.position.set(0, 1, 2.5);
            house.add(door);

            // Windows
            const windowGeo = new THREE.BoxGeometry(1, 1, 0.1);
            
            const win1 = new THREE.Mesh(windowGeo, windowMat);
            win1.position.set(-1.8, 2.5, 2.5);
            house.add(win1);

            const win2 = new THREE.Mesh(windowGeo, windowMat);
            win2.position.set(1.8, 2.5, 2.5);
            house.add(win2);

            return house;
        }

        function createApartment() {
            const apartment = new THREE.Group();

            // Materials
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x90a4ae, flatShading: true, transparent: true, opacity: 0.98 });
            const roomWallMat = new THREE.MeshStandardMaterial({ color: 0xbdc3c7 }); 
            const floorSlabMat = new THREE.MeshStandardMaterial({ color: 0x455a64 });
            const stairMat = new THREE.MeshStandardMaterial({ color: 0x37474f });
            const railMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const windowMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const glowingWindowMat = new THREE.MeshStandardMaterial({ 
                color: 0xfff176, emissive: 0xfff176, emissiveIntensity: 0.6 
            });

            // Building config
            const floors = 5;
            const floorHeight = 4;
            const bWidth = 10;
            const bDepth = 8;
            const bHeight = floors * floorHeight;

            // External Shell
            const body = new THREE.Mesh(new THREE.BoxGeometry(bWidth, bHeight, bDepth), wallMat);
            body.position.y = bHeight / 2;
            apartment.add(body);

            // Internal Structure
            for (let f = 0; f < floors; f++) {
                const yFloorBase = f * floorHeight;

                const slab = new THREE.Mesh(new THREE.BoxGeometry(bWidth - 0.1, 0.2, bDepth - 0.1), floorSlabMat);
                slab.position.y = yFloorBase;
                apartment.add(slab);

                const internalWallH = floorHeight - 0.2;
                const longWall = new THREE.Mesh(new THREE.BoxGeometry(0.1, internalWallH, bDepth - 0.4), roomWallMat);
                longWall.position.set(0, yFloorBase + (internalWallH/2), 0);
                apartment.add(longWall);

                const latWall = new THREE.Mesh(new THREE.BoxGeometry(bWidth - 0.4, internalWallH, 0.1), roomWallMat);
                latWall.position.set(0, yFloorBase + (internalWallH/2), 0);
                apartment.add(latWall);

                const xPositions = [-3, 3];
                xPositions.forEach(xPos => {
                    const isLit = Math.random() > 0.6;
                    const winGeo = new THREE.BoxGeometry(1.8, 1.8, 0.25);
                    
                    const winF = new THREE.Mesh(winGeo, isLit ? glowingWindowMat : windowMat);
                    winF.position.set(xPos, yFloorBase + 2, bDepth/2);
                    apartment.add(winF);

                    const winB = new THREE.Mesh(winGeo, Math.random() > 0.6 ? glowingWindowMat : windowMat);
                    winB.position.set(xPos, yFloorBase + 2, -bDepth/2);
                    apartment.add(winB);
                });
            }

            // Stairs & Handrails
            const stairGroup = new THREE.Group();
            const stepsPerFloor = 12;
            const stepH = floorHeight / stepsPerFloor;
            const railOffset = 1.1;

            for (let f = 0; f < floors; f++) {
                const floorY = f * floorHeight;

                for (let s = 0; s < stepsPerFloor; s++) {
                    const step = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 0.6), stairMat);
                    step.position.set(bWidth/2 + 1, floorY + (s * stepH), 3 - (s * 0.5));
                    stairGroup.add(step);
                }

                const railLength = Math.sqrt(Math.pow(floorHeight, 2) + Math.pow(stepsPerFloor * 0.5, 2));
                const handrail = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, railLength), railMat);
                handrail.position.set(bWidth/2 + 1.9, floorY + (floorHeight/2) + railOffset - 0.5, 0.25);
                handrail.rotation.x = Math.atan2(floorHeight, stepsPerFloor * 0.5);
                stairGroup.add(handrail);

                const postGeo = new THREE.BoxGeometry(0.08, railOffset, 0.08);
                const p1 = new THREE.Mesh(postGeo, railMat);
                p1.position.set(bWidth/2 + 1.9, floorY + railOffset/2, 2.8);
                stairGroup.add(p1);

                const p2 = new THREE.Mesh(postGeo, railMat);
                p2.position.set(bWidth/2 + 1.9, floorY + floorHeight + railOffset/2 - 0.5, -2.2);
                stairGroup.add(p2);

                const landing = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 2.5), stairMat);
                landing.position.set(bWidth/2 + 1, (f + 1) * floorHeight, -2);
                stairGroup.add(landing);
            }
            apartment.add(stairGroup);

            return apartment;
        }

        function createCar() {
            const car = new THREE.Group();
            car.scale.set(1.5, 1.5, 1.5);

            const body = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1, 2),
                new THREE.MeshStandardMaterial({ color: 0xee0000, roughness: 0.3 })
            );
            body.position.y = 0.6;
            car.add(body);

            const cabin = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 0.8, 1.6),
                new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 })
            );
            cabin.position.set(-0.3, 1.5, 0);
            car.add(cabin);

            const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 32);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const wheelPositions = [[1.3, 0.4, 1.1], [-1.3, 0.4, 1.1], [1.3, 0.4, -1.1], [-1.3, 0.4, -1.1]];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(pos[0], pos[1], pos[2]);
                car.add(wheel);
            });

            const bulbGeo = new THREE.SphereGeometry(0.15, 16, 16);
            const bulbMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                emissive: 0xffffee, 
                emissiveIntensity: 2 
            });

            const leftBulb = new THREE.Mesh(bulbGeo, bulbMat);
            leftBulb.position.set(2, 0.7, 0.6);
            car.add(leftBulb);

            const rightBulb = new THREE.Mesh(bulbGeo, bulbMat);
            rightBulb.position.set(2, 0.7, -0.6);
            car.add(rightBulb);

            const createHeadlight = (x, z) => {
                const light = new THREE.SpotLight(0xffffff, 20);
                light.position.set(x, 0.7, z);
                light.target.position.set(x + 5, 0.7, z);
                light.angle = Math.PI / 6;
                light.penumbra = 0.3;
                car.add(light);
                car.add(light.target);
            };
            createHeadlight(2, 0.6);
            createHeadlight(2, -0.6);

            return car;
        }

        function createBus() {
            const bus = new THREE.Group();

            const bodyGeo = new THREE.BoxGeometry(8, 2.5, 3);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffcc00, roughness: 0.4 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.6;
            bus.add(body);

            const hoodGeo = new THREE.BoxGeometry(1.5, 1.2, 2.8);
            const hood = new THREE.Mesh(hoodGeo, bodyMat);
            hood.position.set(4.5, 1.0, 0);
            bus.add(hood);

            const windowMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9, roughness: 0.1 });
            
            const sideWinGeo = new THREE.BoxGeometry(6.5, 0.8, 3.1);
            const sideWindows = new THREE.Mesh(sideWinGeo, windowMat);
            sideWindows.position.set(-0.3, 2.1, 0);
            bus.add(sideWindows);

            const windshieldGeo = new THREE.BoxGeometry(0.1, 1.0, 2.6);
            const windshield = new THREE.Mesh(windshieldGeo, windowMat);
            windshield.position.set(3.96, 2.1, 0);
            bus.add(windshield);

            const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.5, 32);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            
            const wheelPositions = [
                [3, 0.6, 1.3], [3, 0.6, -1.3],
                [-2.5, 0.6, 1.3], [-2.5, 0.6, -1.3]
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(pos[0], pos[1], pos[2]);
                bus.add(wheel);
            });

            const bulbGeo = new THREE.SphereGeometry(0.2, 16, 16);
            const bulbMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffee, emissiveIntensity: 2 });

            const leftBulb = new THREE.Mesh(bulbGeo, bulbMat);
            leftBulb.position.set(5.2, 1.0, 0.9);
            bus.add(leftBulb);

            const rightBulb = new THREE.Mesh(bulbGeo, bulbMat);
            rightBulb.position.set(5.2, 1.0, -0.9);
            bus.add(rightBulb);

            const createHeadlight = (x, z) => {
                const light = new THREE.SpotLight(0xffffff, 30);
                light.position.set(x, 1.0, z);
                light.target.position.set(x + 10, 1.0, z);
                light.angle = Math.PI / 8;
                bus.add(light);
                bus.add(light.target);
            };
            createHeadlight(5.2, 0.9);
            createHeadlight(5.2, -0.9);

            return bus;
        }

        function createFactory() {
            const factoryGroup = new THREE.Group();

            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x222222 });

            // MAIN BUILDING
            const mainBody = new THREE.Mesh(new THREE.BoxGeometry(14, 8, 10), whiteMat);
            mainBody.position.y = 4;
            factoryGroup.add(mainBody);

            // ANNEX
            const annexBody = new THREE.Mesh(new THREE.BoxGeometry(8, 5, 7), whiteMat);
            annexBody.position.set(11, 2.5, 0);
            factoryGroup.add(annexBody);

            // WINDOW CREATOR
            const createWin = (width, height) => {
                const group = new THREE.Group();
                const frame = new THREE.Mesh(new THREE.BoxGeometry(width + 0.2, height + 0.2, 0.2), darkMat);
                const glass = new THREE.Mesh(new THREE.BoxGeometry(width, height, 0.21), new THREE.MeshStandardMaterial({
                    color: 0x88ccff, metalness: 0.9, roughness: 0.1, transparent: true, opacity: 0.5
                }));
                group.add(frame, glass);
                return group;
            };

            const w1 = createWin(2, 2); w1.position.set(-4, 5, 5.01); factoryGroup.add(w1);
            const w2 = createWin(2, 2); w2.position.set(4, 5, 5.01); factoryGroup.add(w2);
            const w3 = createWin(1.5, 1.5); w3.position.set(11, 3.5, 3.51); factoryGroup.add(w3);
            const w4 = createWin(1.5, 1.5); w4.position.set(15, 3.5, 0); w4.rotation.y = Math.PI/2; factoryGroup.add(w4);

            // DOOR
            const door = new THREE.Mesh(new THREE.BoxGeometry(2.5, 4, 0.2), darkMat);
            door.position.set(0, 2, 5.05);
            factoryGroup.add(door);

            // CHIMNEYS
            const chimneyGeo = new THREE.CylinderGeometry(0.6, 0.6, 6, 16);
            const c1 = new THREE.Mesh(chimneyGeo, darkMat); c1.position.set(-4, 10, -2); factoryGroup.add(c1);
            const c2 = new THREE.Mesh(chimneyGeo, darkMat); c2.position.set(4, 10, -2); factoryGroup.add(c2);

            // SMOKE (simplified, animate in loop)
            const smokeParticles = [];
            const smokeMat = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc, transparent: true, opacity: 0.4 
            });

            function spawnSmoke(x, z) {
                const size = 0.4 + Math.random() * 0.5;
                const p = new THREE.Mesh(new THREE.SphereGeometry(size, 8, 8), smokeMat.clone());
                p.position.set(x, 13, z);
                
                p.userData = {
                    vX: (Math.random() - 0.5) * 0.05,
                    vY: 0.05 + Math.random() * 0.05,
                    vZ: (Math.random() - 0.5) * 0.05,
                    life: 1.0
                };
                factoryGroup.add(p);
                smokeParticles.push(p);
            }

            // Add to animation
            function updateSmoke() {
                if (Math.random() > 0.85) {
                    spawnSmoke(-4, -2);
                    spawnSmoke(4, -2);
                }

                for (let i = smokeParticles.length - 1; i >= 0; i--) {
                    const p = smokeParticles[i];
                    p.position.x += p.userData.vX;
                    p.position.y += p.userData.vY;
                    p.position.z += p.userData.vZ;
                    p.userData.life -= 0.005;
                    p.material.opacity = p.userData.life * 0.4;
                    p.scale.setScalar(1 + (1 - p.userData.life) * 4);

                    if (p.userData.life <= 0) {
                        factoryGroup.remove(p);
                        p.geometry.dispose();
                        p.material.dispose();
                        smokeParticles.splice(i, 1);
                    }
                }
            }

            factoryGroup.userData.update = updateSmoke; // For animation loop

            return factoryGroup;
        }

        // --- PLACEMENT LOGIC ---
        let currentType = null;
        const buttons = document.querySelectorAll('#toolbar button');
        buttons.forEach(button => {
            button.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                button.classList.add('active');
                currentType = button.dataset.type;
            });
        });

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseClick(event) {
            if (!currentType) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(terrainMeshes);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                let model;
                switch (currentType) {
                    case 'tree1': model = createTree1(); break;
                    case 'tree2': model = createTree2(); break;
                    case 'house': model = createHouse(); break;
                    case 'apartment': model = createApartment(); break;
                    case 'car': model = createCar(); break;
                    case 'bus': model = createBus(); break;
                    case 'factory': model = createFactory(); break;
                }
                model.position.set(point.x, point.y + 0.5, point.z); // Offset slightly above ground
                scene.add(model);
                updateCarbon(carbonValues[currentType]);
            }
        }

        document.addEventListener('click', onMouseClick);

        // --- ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Update factories' smoke if any
            scene.traverse(child => {
                if (child.userData.update) child.userData.update();
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>